<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chord Colors - Ear Training</title>
    <style>
        :root {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: #c8d6e5;
        }

        .terminal {
            max-width: 800px;
            margin: 0 auto;
            padding: 16px 20px;
        }

        .header {
            color: #00d2d3;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .config-row {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .config-row label {
            color: #778ca3;
        }

        .config-row select {
            font-family: inherit;
            font-size: 13px;
            background: #0f0f23;
            color: #c8d6e5;
            border: 1px solid #334;
            border-radius: 4px;
            padding: 3px 6px;
        }

        .config-row select:focus {
            outline: 1px solid #00d2d3;
        }

        .commands {
            display: flex;
            gap: 6px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .cmd-btn {
            font-family: inherit;
            font-size: 13px;
            background: #0f0f23;
            color: #c8d6e5;
            border: 1px solid #334;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            transition: background 0.1s, border-color 0.1s;
        }

        .cmd-btn:hover {
            background: #1e1e3a;
            border-color: #00d2d3;
        }

        .cmd-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .cmd-btn .key {
            color: #feca57;
        }

        .reveal-inline {
            font-size: 14px;
            font-weight: 700;
            color: #54a0ff;
            min-width: 60px;
            display: inline-block;
        }

        .log {
            margin-top: 10px;
            padding: 10px 12px;
            background: #0f0f23;
            border: 1px solid #222;
            border-radius: 6px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }

        .log-line { margin: 0; }
        .log-line.info { color: #778ca3; }
        .log-line.note { color: #c8d6e5; }
        .log-line.correct { color: #2ed573; }
        .log-line.wrong { color: #ff6b6b; }
        .log-line.reveal { color: #54a0ff; }
        .log-line.heading { color: #00d2d3; font-weight: 700; }
        .log-line.warn { color: #feca57; }

        .stats {
            margin-top: 8px;
            font-size: 12px;
            color: #778ca3;
            display: flex;
            gap: 16px;
        }

        .stats .val { color: #c8d6e5; }

        .available-chords {
            margin-top: 6px;
            font-size: 12px;
            color: #778ca3;
        }

        .available-chords .chords { color: #c8d6e5; }
    </style>
</head>

<body>
<div class="terminal">
    <div class="header">Chord Colors - Ear Training</div>

    <div class="config-row">
        <label>key:</label>
        <select id="keySelect"></select>
        <label>level:</label>
        <select id="levelSelect"></select>
        <label>octave shift:</label>
        <select id="octaveShiftSelect"></select>
        <button class="cmd-btn" id="startBtn">start</button>
    </div>

    <div class="commands">
        <button class="cmd-btn" id="nextBtn" disabled>[<span class="key">n</span>] next</button>
        <button class="cmd-btn" id="againBtn" disabled>[<span class="key">a</span>] again</button>
        <button class="cmd-btn" id="melodicBtn" disabled>[<span class="key">m</span>] melodic</button>
        <button class="cmd-btn" id="revealBtn" disabled>[<span class="key">r</span>] reveal</button>
        <span id="revealDisplay" class="reveal-inline"></span>
        <button class="cmd-btn" id="levelUpBtn" disabled>[<span class="key">l</span>] level up</button>
    </div>

    <div class="stats">
        <span>count: <span class="val" id="countDisplay">0</span></span>
        <span>elapsed: <span class="val" id="elapsedDisplay">0:00</span></span>
        <span>level: <span class="val" id="levelDisplay">1</span></span>
    </div>

    <div class="available-chords">
        chords: <span id="availableChords" class="chords">-</span>
    </div>

    <div id="log" class="log"></div>
</div>

<script src="tiul-constants.js"></script>
<script src="tiul-piano.js"></script>

<script>
    (function () {
        // ============================================================
        // WHITE KEY CHORDS (from constants.py)
        // ============================================================

        const WHITE_KEY_CHORDS = {
            'CEG': ['C4','E4','G4'],
            'CFA': ['C4','F4','A4'],
            'BDG': ['B3','D4','G4'],
            'ACF': ['A3','C4','F4'],
            'DGB': ['D4','G4','B4'],
            'EGC': ['E4','G4','C5'],
            'FAC': ['F4','A4','C5'],
            'GBD': ['G4','B4','D5'],
            'GCE': ['G4','C5','E5']
        };

        const CHORD_NAMES = Object.keys(WHITE_KEY_CHORDS);
        const MIN_LEVEL = 1;
        const MAX_LEVEL = 9;

        // ============================================================
        // TRANSPOSITION (port of transpose_white_key_chords_spelled)
        // ============================================================

        const NOTE_NAMES = ['C','D','E','F','G','A','B'];
        const MAJOR_SCALE_INTERVALS = [0, 2, 4, 5, 7, 9, 11];

        function noteNameToMidi(name) {
            const m = /^([A-G])(#{0,2}|b{0,2}|-{0,2})(\d+)$/.exec(name);
            if (!m) return null;
            const letter = m[1];
            const accStr = m[2];
            const octave = parseInt(m[3], 10);
            const base = LETTER_TO_SEMITONE[letter];
            let acc = 0;
            for (const ch of accStr) {
                if (ch === '#') acc++;
                else if (ch === 'b' || ch === '-') acc--;
            }
            return (octave + 1) * 12 + base + acc;
        }

        function buildMajorScale(keyName) {
            // Build the 7 scale degree note names for a key
            const offset = KEY_OFFSETS[keyName];
            if (offset === undefined) return null;

            // Use first 7 entries from KEY_DEGREES for this key
            const degrees = KEY_DEGREES[keyName];
            if (!degrees) return null;

            // Build pitch-class (0-11) to spelled-name map from scale degrees
            const pcToName = {};
            for (let i = 0; i < 7; i++) {
                const parsed = parseTiulName(degrees[i]);
                const base = LETTER_TO_SEMITONE[parsed.letter];
                const pc = ((base + parsed.accSemitones) % 12 + 12) % 12;
                pcToName[pc] = parsed.displayName;
            }
            return { offset, pcToName };
        }

        function transposeChords(keyName) {
            if (keyName === 'C') return WHITE_KEY_CHORDS;

            const scale = buildMajorScale(keyName);
            if (!scale) return WHITE_KEY_CHORDS;

            const result = {};
            for (const [chordName, pitches] of Object.entries(WHITE_KEY_CHORDS)) {
                const transposedPitches = [];
                for (const pitchStr of pitches) {
                    const origMidi = noteNameToMidi(pitchStr);
                    const newMidi = origMidi + scale.offset;
                    const pc = ((newMidi % 12) + 12) % 12;
                    const correctName = scale.pcToName[pc];
                    if (!correctName) {
                        // fallback
                        transposedPitches.push(midiToSoundfontName(newMidi));
                        continue;
                    }

                    // Calculate octave accounting for enharmonic boundary
                    let octave = Math.floor(newMidi / 12) - 1;
                    if (correctName.startsWith('B') && correctName.includes('#')) {
                        octave -= 1;
                    } else if (correctName.startsWith('C') && (correctName.includes('b') || correctName.includes('-'))) {
                        octave += 1;
                    }

                    transposedPitches.push(correctName + octave);
                }

                const newChordName = transposedPitches.map(p => p.replace(/\d+$/, '')).join(',');
                result[newChordName] = transposedPitches;
            }
            return result;
        }

        // ============================================================
        // DOM
        // ============================================================

        const keySelect = document.getElementById('keySelect');
        const levelSelect = document.getElementById('levelSelect');
        const octaveShiftSelect = document.getElementById('octaveShiftSelect');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');
        const againBtn = document.getElementById('againBtn');
        const melodicBtn = document.getElementById('melodicBtn');
        const revealBtn = document.getElementById('revealBtn');
        const revealDisplay = document.getElementById('revealDisplay');
        const levelUpBtn = document.getElementById('levelUpBtn');
        const logDiv = document.getElementById('log');
        const countDisplay = document.getElementById('countDisplay');
        const elapsedDisplay = document.getElementById('elapsedDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const availableChordsEl = document.getElementById('availableChords');

        // Populate selects
        KEY_ORDER.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            opt.textContent = k.replace('-', 'b');
            keySelect.appendChild(opt);
        });
        keySelect.value = 'C';

        for (let i = MIN_LEVEL; i <= MAX_LEVEL; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = i;
            levelSelect.appendChild(opt);
        }

        for (let i = 0; i <= 2; i++) {
            const opt = document.createElement('option');
            opt.value = i;
            opt.textContent = i;
            octaveShiftSelect.appendChild(opt);
        }

        // ============================================================
        // LOG
        // ============================================================

        function log(text, cls) {
            const p = document.createElement('p');
            p.className = 'log-line ' + (cls || 'note');
            p.textContent = text;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            logDiv.innerHTML = '';
        }

        // ============================================================
        // SESSION STATE
        // ============================================================

        let session = null;

        function createSession(keyName, level, octaveShiftRange) {
            const chords = transposeChords(keyName);
            const chordNames = Object.keys(chords);
            return {
                key: keyName,
                chords: chords,
                chordNames: chordNames,
                level: Math.min(level, chordNames.length),
                octaveShiftRange: octaveShiftRange,
                currentChordIndex: 0,
                currentChordName: null,
                lastPlayedMidis: null,
                lastOctaveShift: 0,
                count: 0,
                startTime: Date.now()
            };
        }

        function getAvailableChords(s) {
            return s.chordNames.slice(0, s.level);
        }

        function chordToMidis(s, chordName, octaveShift) {
            const pitches = s.chords[chordName];
            return pitches.map(p => noteNameToMidi(p) + octaveShift * 12);
        }

        // ============================================================
        // AUDIO
        // ============================================================

        function playHarmonic(s) {
            const shift = s.octaveShiftRange > 0
                ? Math.floor(Math.random() * (2 * s.octaveShiftRange + 1)) - s.octaveShiftRange
                : 0;
            s.lastOctaveShift = shift;
            const midis = chordToMidis(s, s.currentChordName, shift);
            s.lastPlayedMidis = midis;
            TiulPiano.stopAll();
            TiulPiano.playChord(midis, 2.0);
        }

        function playAgain(s) {
            if (s.lastPlayedMidis) {
                TiulPiano.stopAll();
                TiulPiano.playChord(s.lastPlayedMidis, 2.0);
            }
        }

        function playMelodic(s) {
            if (!s.currentChordName) return;
            const midis = s.lastPlayedMidis || chordToMidis(s, s.currentChordName, 0);
            TiulPiano.stopAll();
            midis.forEach((midi, i) => {
                setTimeout(() => TiulPiano.play(midi, 1.0), i * 500);
            });
        }

        // ============================================================
        // UI UPDATE
        // ============================================================

        function updateStats() {
            if (!session) return;
            countDisplay.textContent = session.count;
            levelDisplay.textContent = session.level;

            const elapsed = Math.floor((Date.now() - session.startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            elapsedDisplay.textContent = mins + ':' + (secs < 10 ? '0' : '') + secs;
        }

        function updateAvailableChords() {
            if (!session) return;
            availableChordsEl.textContent = getAvailableChords(session).join('  ');
        }

        function setCommandsEnabled(enabled) {
            nextBtn.disabled = !enabled;
            againBtn.disabled = !enabled;
            melodicBtn.disabled = !enabled;
            revealBtn.disabled = !enabled;
            levelUpBtn.disabled = !enabled;
        }

        // ============================================================
        // ACTIONS
        // ============================================================

        function doStart() {
            if (!TiulPiano.isReady()) { log('Piano not loaded yet.', 'warn'); return; }

            const keyName = keySelect.value;
            const level = parseInt(levelSelect.value, 10);
            const octaveShift = parseInt(octaveShiftSelect.value, 10);

            session = createSession(keyName, level, octaveShift);
            clearLog();
            revealDisplay.textContent = '';

            log('Chord Colors Training Started!', 'heading');
            log('Key: ' + keyName + ' | Level: ' + session.level + ' | Octave shift: ' + octaveShift, 'info');
            log('Commands: (n)ext, (a)gain, (m)elodic, (r)eveal, (l)evel up', 'info');
            log('', 'info');

            updateAvailableChords();

            // Play first chord
            session.currentChordIndex = Math.floor(Math.random() * session.level);
            session.currentChordName = getAvailableChords(session)[session.currentChordIndex];
            session.count++;
            playHarmonic(session);

            log('Chord #' + session.count + ' played.', 'info');
            setCommandsEnabled(true);
            updateStats();
        }

        function doNext() {
            if (!session) return;
            if (!TiulPiano.isReady()) return;
            revealDisplay.textContent = '';

            const available = getAvailableChords(session);
            session.currentChordIndex = Math.floor(Math.random() * available.length);
            session.currentChordName = available[session.currentChordIndex];
            session.count++;
            playHarmonic(session);

            log('Chord #' + session.count + ' played.', 'info');
            updateStats();
        }

        function doAgain() {
            if (!session) return;
            playAgain(session);
            log('(replayed)', 'info');
        }

        function doMelodic() {
            if (!session) return;
            playMelodic(session);
            log('(melodic)', 'info');
        }

        function doReveal() {
            if (!session) return;
            if (session.currentChordName) {
                revealDisplay.textContent = session.currentChordName;
                log('Revealed: ' + session.currentChordName, 'reveal');
                updateStats();
            } else {
                log('No chord played yet.', 'warn');
            }
        }

        function doLevelUp() {
            if (!session) return;
            if (session.level >= MAX_LEVEL || session.level >= session.chordNames.length) {
                log('Already at maximum level (' + session.level + ')', 'warn');
                return;
            }
            session.level++;
            updateAvailableChords();
            updateStats();
            log('Level up! Now level ' + session.level + ' - Chords: ' + getAvailableChords(session).join(', '), 'heading');
        }

        // ============================================================
        // EVENT LISTENERS
        // ============================================================

        startBtn.addEventListener('click', doStart);
        nextBtn.addEventListener('click', doNext);
        againBtn.addEventListener('click', doAgain);
        melodicBtn.addEventListener('click', doMelodic);
        revealBtn.addEventListener('click', doReveal);
        levelUpBtn.addEventListener('click', doLevelUp);

        const SHORTCUTS = { 'N': doNext, 'A': doAgain, 'M': doMelodic, 'R': doReveal, 'L': doLevelUp };
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            const handler = SHORTCUTS[e.key.toUpperCase()];
            if (handler) {
                e.preventDefault();
                e.stopImmediatePropagation();
                handler();
            }
        }, true);

        // ============================================================
        // INIT AUDIO
        // ============================================================

        function initAudio() {
            log('Loading piano samples...', 'info');
            TiulPiano.init(
                function () {
                    log('Piano loaded. Select key and level, then press start.', 'heading');
                    startBtn.disabled = false;
                },
                function (e) {
                    log('Error loading piano: ' + e.message, 'wrong');
                }
            );
        }

        initAudio();
    })();
</script>
</body>
</html>
